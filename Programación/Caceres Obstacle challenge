//OBSTACLE CHALLENGE CODE

#include <ESP32Servo.h>                                                   // LIBRARIES DEFINITION
#include <Wire.h>
#include <VL53L1X.h>
#include <Adafruit_TCS34725.h>
#include "HUSKYLENS.h"

Servo servo;                                                              // LIBRARY VARIABLES DEFINITION
const uint8_t sensorCount = 3;                                            // NUMBER OF DISTANCE SENSORS                                                             // VARIABLE DEFINITION
VL53L1X sensors[sensorCount];
Adafruit_TCS34725 tcs = Adafruit_TCS34725();
HUSKYLENS huskylens;

const int motorA = 2;                                                     // MOTOR PINS
const int motorB = 27;  
const int ENA    = 32;   

const int buttonPin = 13;                                                  // START BUTTON PIN

const uint8_t xshutPins[sensorCount] = {23,5,14};                         // DISTANCE SENSORS XSHUT PINS


int buttonState = HIGH;                                                   //GLOBAL VARIABLES DEFINITION
int LapCount = 0;
long DelayLine = 0;
long MotorMillis = 0;
long PrevMillis = 0;
long PrevMillisF = 0;
int TravelSense = 1;
int CRearSeq=0;

void setup() {
  Serial.begin(115200);
  Wire.begin();                                                           //INITIALIZE I2C 0 ON DEFAULT PINS 21, 22
  Wire1.begin(16,17);                                                     //INITIALIZE I2C 1 ON DEFAULT PINS 16, 17 
  
  servo.attach(26);                                                       //INITIALIZE SERVO ON PIN 26
  servo.write(97);                                                        //0 POSITION SERVO  
  
  pinMode(buttonPin, INPUT_PULLUP);                                       //START BUTTON 
  
  pinMode(motorA, OUTPUT);                                                //MOTOR OUTPUTS
  pinMode(motorB, OUTPUT);
  digitalWrite(motorA, LOW);                                              //STOP MOTOR
  digitalWrite(motorB, LOW);
  
  ledcAttachChannel(ENA, 2500, 8, 2);                                     //PWM OUTPUT MOTOR 
  
 
  for (uint8_t i = 0; i < sensorCount; i++)                               //INITIALIZE DISTANCE SENSORS 
  {
    pinMode(xshutPins[i], OUTPUT);
    digitalWrite(xshutPins[i], LOW);
  }  
  for (uint8_t i = 0; i < sensorCount; i++)
  {    
    pinMode(xshutPins[i], INPUT);
    delay(10);
    sensors[i].setTimeout(500);
    if (!sensors[i].init())
    {
      Serial.print("Failed to detect and initialize sensor ");
      Serial.println(i);
      while (1);
    }    
    sensors[i].setAddress(0x3A + i);                                      //I2C ADDRESSS SENSORS    
    sensors[i].setDistanceMode(VL53L1X::Long);
    sensors[i].setMeasurementTimingBudget(33000);
    sensors[i].startContinuous(33);
  }

  if (tcs.begin(0x29,&Wire1)) {                                           //INITIALIZE COLOR SENSOR 
    Serial.println("Found sensor");
  } else {
    Serial.println("No TCS34725 found ... check your connections");
    while (1);
  }

  int countButton = 0;                                                    //WAIT FOR START BUTTON
  while (countButton <= 10) {
    buttonState = digitalRead(buttonPin);
    if (buttonState == LOW) countButton++;
    delay(10);
  }  

  huskylens.begin(Wire);                                                  // SET HUSKYLENS TO COLOR RECOGNITION MODE
  huskylens.writeAlgorithm(ALGORITHM_COLOR_RECOGNITION);
  
}

void loop() {
  uint16_t r, g, b, c, colorTemp;

  tcs.getRawData(&r, &g, &b, &c);
  colorTemp = tcs.calculateColorTemperature_dn40(r, g, b, c);

  Serial.print("Color Temp: "); Serial.print(colorTemp, DEC);             //INFORMATION FOR COLOR SENSOR CALIBRATION
  if (colorTemp > 5100){                                                  //CALIBRATE BEFORE ROUND
    if ((PrevMillis + 1000)<=millis()){
      PrevMillis = millis();
      if (TravelSense >= 2) LapCount--;
      else LapCount++;
    }
  }  

  if (LapCount >= 12) {                                                   //STOP CAR IF NUMBER OF LAPS REACHED
    if ((MotorMillis + 3500) <= millis()) {
      TravelSense=0;    
    }
  } else {    
    MotorMillis = millis();
  }

  switch( TravelSense){                                                   //CAR GO FORWARD, REVERSE OR STOP
    case 0: digitalWrite(motorA, LOW);
            digitalWrite(motorB, LOW);
    break;
    case 1: digitalWrite(motorA, HIGH);
            digitalWrite(motorB, LOW);
    break;
    case 2: digitalWrite(motorA, LOW);
            digitalWrite(motorB, HIGH);
    break;
    
   }
  
  drive();                                                                //CAR MOVEMENT
}


void drive() {
  static signed int distanceRight,distanceLeft,distanceFront;
  static int CountCorrection=0;
  static signed int correction=0;

  if (huskylens.request()) {                                              // OBTAIN DATA FROM HUSKYLENS
    for (int i = 0; i < huskylens.countBlocks(); i++) {
      HUSKYLENSResult result = huskylens.getBlock(i);
      if (result.ID==1 && result.width>30) {                              // ID1 = GREEN
        CountCorrection=20;                            
        correction=-40;
      }
      else if (result.ID==2 && result.width>30) {                         // ID2 = RED
        CountCorrection=20;
        correction=40;
      }
    }
  }
  
  if (sensors[0].dataReady()){                                            //READ DISTANCE SENSORS
    distanceRight = sensors[0].read(false);
    if (distanceRight>1500) distanceRight=1500;
    }  

  if (sensors[1].dataReady()){
    distanceLeft = sensors[1].read(false);
    if (distanceLeft>1500) distanceLeft=1500;
    }  
  
  if (sensors[2].dataReady()){
    distanceFront = sensors[2].read(false);}
  
  if (distanceFront<200){                                                             //IF FRONT SENSOR DETECTS OBSTACLE INIT REAR SEQUENCE
    if ((PrevMillisF + 1500)<=millis()){
      PrevMillisF = millis();
      CRearSeq=100;
      }
    }
   
  if(CRearSeq>=90) TravelSense=0;                                                     //REAR SEQUENCE
  if(CRearSeq>0 && CRearSeq<90) TravelSense=2;
  if(CRearSeq==1) TravelSense=1;
  if(CRearSeq>0) CRearSeq--;

  signed int dServo = (distanceRight - distanceLeft )/20;                             //TURN ALGORITHM
  if (dServo > 40) dServo = 40;
  if (dServo < -40) dServo = -40;
  if (CountCorrection>0) {
    dServo=correction;
    CountCorrection--;
    } 
  if (TravelSense >=2) servo.write(-dServo + 100);
  else if (TravelSense ==1)servo.write(dServo + 100);
  
  if (dServo>=0) ledcWrite(ENA,140+dServo);                                           //ADJUST MOTOR SPEED WHEN TURNING
    else ledcWrite(ENA, 140-dServo);
}
